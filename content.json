[{"title":"mysql隐式转换","date":"2017-04-25T08:58:05.000Z","path":"2017/04/25/mysql-implicit-conversions/","text":"前言在使用mysql过程中，可能经常遇到两类问题： 这个字段明明有索引，但是查询依然很慢，执行计划竟然不走索引？？？ 这个sql看起来没什么问题，为什么就是没有拿到预期的数据？mysql出bug了？ 这时候不妨停下来思考一下，是不是查询条件的数据类型和表字段类型不匹配，mysql执行时发生了隐式转换，可以通过 show warnings; 看看是否有警告。 转换潜规则先去官方文档看看隐式转换的潜规则：官方文档摘取片段： The following rules describe how conversion occurs for comparison operations: If one or both arguments are NULL, the result of the comparison is NULL, except for the NULL-safe &lt;=&gt; equality comparison operator. For NULL &lt;=&gt; NULL, the result is true. No conversion is needed. If both arguments in a comparison operation are strings, they are compared as strings. If both arguments are integers, they are compared as integers. Hexadecimal values are treated as binary strings if not compared to a number. If one of the arguments is a TIMESTAMP or DATETIME column and the other argument is a constant, the constant is converted to a timestamp before the comparison is performed. This is done to be more ODBC-friendly. Note that this is not done for the arguments to IN()! To be safe, always use complete datetime, date, or time strings when doing comparisons. For example, to achieve best results when using BETWEEN with date or time values, use CAST() to explicitly convert the values to the desired data type. A single-row subquery from a table or tables is not considered a constant. For example, if a subquery returns an integer to be compared to a DATETIME value, the comparison is done as two integers. The integer is not converted to a temporal value. To compare the operands as DATETIME values, use CAST() to explicitly convert the subquery value to DATETIME. If one of the arguments is a decimal value, comparison depends on the other argument. The arguments are compared as decimal values if the other argument is a decimal or integer value, or as floating-point values if the other argument is a floating-point value. In all other cases, the arguments are compared as floating-point (real) numbers. 翻译过来就是： 两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 &lt;=&gt; 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换; 两个参数都是字符串，会按照字符串来比较，不做类型转换; 两个参数都是整数，按照整数来比较，不做类型转换; 十六进制的值和非数字做比较时，会被当做二进制串; 有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp; 有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较; 所有其他情况下，两个参数都会被转换为浮点数再进行比较; 实战的坑先建一个表：12345678910CREATE TABLE `scores` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;id&apos;, `name` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;姓名&apos;, `course` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;课程&apos;, `score` int(11) DEFAULT &apos;0&apos; COMMENT &apos;分数&apos;, PRIMARY KEY (`id`), KEY `idx_name_course` (`name`,`course`), KEY `idx_course` (`course`), KEY `idx_score` (`score`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin 表中数据如下：12345678910111213141516mysql&gt; select * from `scores`;+----+--------+--------+-------+| id | name | course | score |+----+--------+--------+-------+| 1 | 张三 | 语文 | 89 || 2 | 张三 | 数学 | 79 || 3 | 张三 | 英语 | 96 || 4 | 李四 | 语文 | 90 || 5 | 李四 | 数学 | 85 || 6 | 李四 | 英语 | 94 || 7 | 王五 | 语文 | 87 || 8 | 王五 | 英语 | 94 || 9 | 11aaa | 语文 | 100 || 10 | 11bbb | 数学 | 89 |+----+--------+--------+-------+10 rows in set (0.00 sec) 注意varchar和int之间的参数转换：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758mysql&gt; select * from `scores` where name = 0;+----+--------+--------+-------+| id | name | course | score |+----+--------+--------+-------+| 1 | 张三 | 语文 | 89 || 2 | 张三 | 数学 | 79 || 3 | 张三 | 英语 | 96 || 4 | 李四 | 语文 | 90 || 5 | 李四 | 数学 | 85 || 6 | 李四 | 英语 | 94 || 7 | 王五 | 语文 | 87 || 8 | 王五 | 英语 | 94 |+----+--------+--------+-------+8 rows in set, 10 warnings (0.00 sec)mysql&gt; show warnings;+---------+------+--------------------------------------------+| Level | Code | Message |+---------+------+--------------------------------------------+| Warning | 1292 | Truncated incorrect DOUBLE value: &apos;张三&apos; || Warning | 1292 | Truncated incorrect DOUBLE value: &apos;张三&apos; || Warning | 1292 | Truncated incorrect DOUBLE value: &apos;张三&apos; || Warning | 1292 | Truncated incorrect DOUBLE value: &apos;李四&apos; || Warning | 1292 | Truncated incorrect DOUBLE value: &apos;李四&apos; || Warning | 1292 | Truncated incorrect DOUBLE value: &apos;李四&apos; || Warning | 1292 | Truncated incorrect DOUBLE value: &apos;王五&apos; || Warning | 1292 | Truncated incorrect DOUBLE value: &apos;王五&apos; || Warning | 1292 | Truncated incorrect DOUBLE value: &apos;11aaa&apos; || Warning | 1292 | Truncated incorrect DOUBLE value: &apos;11bbb&apos; |+---------+------+--------------------------------------------+10 rows in set (0.00 sec)mysql&gt; select * from `scores` where name = 11;+----+-------+--------+-------+| id | name | course | score |+----+-------+--------+-------+| 9 | 11aaa | 语文 | 100 || 10 | 11bbb | 数学 | 89 |+----+-------+--------+-------+2 rows in set, 10 warnings (0.00 sec)mysql&gt; select * from `scores` where name = 11 + &apos;aaa&apos;;+----+-------+--------+-------+| id | name | course | score |+----+-------+--------+-------+| 9 | 11aaa | 语文 | 100 || 10 | 11bbb | 数学 | 89 |+----+-------+--------+-------+2 rows in set, 11 warnings (0.00 sec)mysql&gt; select * from `scores` where name = &apos;11&apos; + &apos;aaa&apos;;+----+-------+--------+-------+| id | name | course | score |+----+-------+--------+-------+| 9 | 11aaa | 语文 | 100 || 10 | 11bbb | 数学 | 89 |+----+-------+--------+-------+2 rows in set, 11 warnings (0.00 sec) 此时已经发生隐式转换了；满足上述最后一条，name字段和int比较，name字段转换成浮点数，转换后再去比较。 但是上面的转换结果很令人匪夷所思啊？？？下面再来看栗子： 1.字符串转换的潜规则：1234567mysql&gt; select &apos;张三&apos; + 1;+--------------+| &apos;张三&apos; + 1 |+--------------+| 1 |+--------------+1 row in set, 1 warning (0.00 sec) 根据官方文档： When an operator is used with operands of different types, type conversion occurs to make the operands compatible.当一个操作符对应不同类型，那么类型转换主要为了使操作符兼容，并且按照之前隐式转换规则来，所以上述sql中字符串被转成浮点数进行求和，’张三’被转成0； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mysql&gt; select &apos;1sss&apos; + 1;+------------+| &apos;1sss&apos; + 1 |+------------+| 2 |+------------+1 row in set, 1 warning (0.00 sec)mysql&gt; select &apos;sss1&apos; + 1;+------------+| &apos;sss1&apos; + 1 |+------------+| 1 |+------------+1 row in set, 1 warning (0.00 sec)mysql&gt; select &apos;sss1&apos; + &apos;1&apos;;+--------------+| &apos;sss1&apos; + &apos;1&apos; |+--------------+| 1 |+--------------+1 row in set, 1 warning (0.00 sec)mysql&gt; select &apos;1sss&apos; + &apos;1&apos;;+--------------+| &apos;1sss&apos; + &apos;1&apos; |+--------------+| 2 |+--------------+1 row in set, 1 warning (0.00 sec)mysql&gt; select &apos;1sss&apos; + &apos;sss1&apos;;+-----------------+| &apos;1sss&apos; + &apos;sss1&apos; |+-----------------+| 1 |+-----------------+1 row in set, 2 warnings (0.00 sec)mysql&gt; select &apos;1sss&apos; + &apos;1sss&apos;;+-----------------+| &apos;1sss&apos; + &apos;1sss&apos; |+-----------------+| 2 |+-----------------+1 row in set, 2 warnings (0.00 sec) If any of the operands of a +, -, /, *, % is a real or string value, the precision of the result is the precision of the operand with the maximum precision. 看完上述几个例子，相信读者已经有一些感觉了； 对于 +, -, /, *, % 面对的操作数主要为浮点数，对于字符串会进行隐式转换；更多信息见 官方文档 2.条件查询字符串和数字类型参数的比较：12345678910111213141516171819202122232425262728293031mysql&gt; select &apos;1sss&apos; = 0; +------------+ | &apos;1sss&apos; = 0 | +------------+ | 0 | +------------+ 1 row in set, 1 warning (0.00 sec) mysql&gt; select &apos;1sss&apos; = 1; +------------+ | &apos;1sss&apos; = 1 | +------------+ | 1 | +------------+ 1 row in set, 1 warning (0.00 sec) mysql&gt; select &apos;sss1&apos; = 0; +------------+ | &apos;sss1&apos; = 0 | +------------+ | 1 | +------------+ 1 row in set, 1 warning (0.00 sec) mysql&gt; select &apos;sss1&apos; = 1; +------------+ | &apos;sss1&apos; = 1 | +------------+ | 0 | +------------+ 1 row in set, 1 warning (0.00 sec) 从上面的例子可以看出，当把字符串转为数字的时候，其实是从最左边开始处理的： 如果字符串的第一个字符就是非数字的字符，那么转换为数字就是0； 如果字符串中都是数字，那么转换为数字就是整个字符串对应的数字； 如果字符串中存在非数字，那么转换为的数字就是开头的那些数字对应的值； 3.浮点数转换要注意最大值和精度丢失问题： Comparisons that use floating-point numbers (or values that are converted to floating-point numbers) are approximate because such numbers are inexact. This might lead to results that appear inconsistent;Such results can occur because the values are converted to floating-point numbers, which have only 53 bits of precision and are subject to rounding; 在进行浮点数转换时，可能用科学计数法表示，然后再进行比较，由于精度丢失，导致不正确的结果：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455mysql&gt; select &apos;9223372036854775807&apos; = 9223372036854775807;+---------------------------------------------+| &apos;9223372036854775807&apos; = 9223372036854775807 |+---------------------------------------------+| 1 |+---------------------------------------------+1 row in set (0.00 sec)mysql&gt; select &apos;9223372036854775807&apos; = 9223372036854775808;+---------------------------------------------+| &apos;9223372036854775807&apos; = 9223372036854775808 |+---------------------------------------------+| 1 |+---------------------------------------------+1 row in set (0.00 sec)mysql&gt; select &apos;9223372036854775808&apos; = 9223372036854775808;+---------------------------------------------+| &apos;9223372036854775808&apos; = 9223372036854775808 |+---------------------------------------------+| 1 |+---------------------------------------------+1 row in set (0.00 sec)mysql&gt; select &apos;9223372036854775808&apos; = 9223372036854775807;+---------------------------------------------+| &apos;9223372036854775808&apos; = 9223372036854775807 |+---------------------------------------------+| 1 |+---------------------------------------------+1 row in set (0.00 sec)mysql&gt; select &apos;922337203&apos; = 922337203;+-------------------------+| &apos;922337203&apos; = 922337203 |+-------------------------+| 1 |+-------------------------+1 row in set (0.00 sec)mysql&gt; select &apos;922337203&apos; = 922337202;+-------------------------+| &apos;922337203&apos; = 922337202 |+-------------------------+| 0 |+-------------------------+1 row in set (0.00 sec)mysql&gt; select &apos;9223372036854775808&apos; + 0.0;+-----------------------------+| &apos;9223372036854775808&apos; + 0.0 |+-----------------------------+| 9.223372036854776e18 |+-----------------------------+1 row in set (0.00 sec)","tags":[{"name":"mysql","slug":"mysql","permalink":"https://shiqiupp.github.io/tags/mysql/"}]},{"title":"Java 文件读取","date":"2017-04-10T09:32:46.000Z","path":"2017/04/10/java-fileread/","text":"背景在Java开发过程中，偶尔需要获取一个文件(最常见的就是获取配置文件)，但是经常遇到找不到文件的异常；通常有两种情况： 文件路径不正确； 文件名不正确； 绝大多数异常都是由文件路径不正确导致。但是文件路径应该怎么描述呢？再加上绝对路径，相对路径，想想头大，每次都是尝试好多遍都不一定能搞定；so，在此记录下关于Java中获取文件路径的方法。 文件路径获取目前Java中获取文件路径主要有如下几种方式：注：文中出现的 ‘Xxxx’ 为具体某个类名；操作系统为win7； Xxxx.class.getResource(“”) 得到的是Xxxx.class类文件所在的文件目录(当前类文件的绝对URI目录)。如：file:/D:/Projects/path-study/target/classes/com/beta/study/Xxxx.class.getResource(“”).getPath() 可以获取不带前缀的文件路径。如： /D:/Projects/path-study/target/classes/com/beta/study/ Xxxx.class.getResource(“/“) 得到的是Xxxx.class类文件所在的类文件根目录(当前类文件classpath的绝对URI目录)。如：file:/D:/Projects/path-study/target/classes/Xxxx.class.getResource(“/“).getPath() 可以获取不带前缀的文件路径。如： /D:/Projects/path-study/target/classes/ Xxxx.class.getClassLoader().getResource(“”) 注意此处getResource()参数中没有 / ，如果这样Xxxx.class.getClassLoader().getResource(“/“) 将得到null(jdk7，jdk8)得到的是Xxxx.class类文件所在的类文件根目录(当前类文件classpath的绝对URI目录)。如：file:/D:/Projects/path-study/target/classes/Xxxx.class.getClassLoader().getResource(“/“).getPath() 可以获取不带前缀的文件路径。如： /D:/Projects/path-study/target/classes/ ClassLoader.getSystemResource(“”) getSystemResource()参数中没有 / ，如果这样ClassLoader.getSystemResource(“”) 将得到null(jdk7，jdk8)得到的是当前类文件classpath的绝对URI目录。如：file:/D:/Projects/path-study/target/classes/ClassLoader.getSystemResource(“”).getPath() 可以获取不带前缀的文件路径。如： /D:/Projects/path-study/target/classes/ Thread.currentThread().getContextClassLoader().getResource(“”) 得到的是当前类文件classpath的绝对URI目录。如：file:/D:/Projects/path-study/target/classes/Thread.currentThread().getContextClassLoader ().getResource(“”).getPath() 可以获取不带前缀的文件路径。如： /D:/Projects/path-study/target/classes/ System.getProperty(“java.class.path”) 获取java -classpath 执行参数指定下的路径。默认为执行时当前CLASS_PATH环境变量；如果用java -classpath “D:\\Projects” Xxxx ; 那么结果为：D:\\Projects ；注意要保证 Xxxx.class 在 D:\\Projects 下面； 文件读取背景知识文件读取一般有两种方式： 1.使用jdk的File api ：1File file = new File(\"文件路径\"); File构造函数参数为文件的路径，可以是绝对路径(如：D:/Projects/path-study/target/classes/test.properties)，也可以是相对路径(test.properties)；如果是相对路径，那么jdk会根据user.dir属性值+相对路径作为文件的路径；系统属性 user.dir是JVM启动的时候设置的，通常是 Java 虚拟机的调用目录，即执行java命令所在的目录；12345//如果当前工作目录为D:/Projects/path-study 那么下面代码等价File file = new File(\"test.properties\");// 等价于(其中System.getProperty(\"user.dir\") = D:/Projects/path-study)：File file = new File(System.getProperty(\"user.dir\") + \"/test.properties\"); so，用File读取文件有隐藏的路径含义，对于实际项目，开发和线上部署环境经常不同，如果用 File file = new File(“文件路径”);来读取文件，那么文件路径将会很头大，所以可以采用其他方式读取，降低FileNotFoundException出现的概率；当然也可以通过上述路径获取方式来获取文件的路径前缀，但是显得不够直接，容易出问题； 2.使用Class.getResource()或ClassLoader.getResource()ClassLoader.getResource() 其中ClassLoader与如下两种也等价： Xxxx.class.getClassLoader() Thread.currentThread().getContextClassLoader() 假设Xxxx.class当前目录为：D:/Projects/path-study/target/classes/com/beta/study/1234Xxxx.class.getResource(\"test.properties\"); //读取D:/Projects/path-study/target/classes/com/beta/study/test.properties或者其他jar中com/beta/study/test.propertiesXxxx.class.getResource(\"/test.properties\"); //读取D:/Projects/path-study/target/classes/test.properties或者其他jar中test.properties Xxxx.class.getClassLoader().getResource(\"test.properties\"); //读取D:/Projects/path-study/target/classes/test.properties或者其他jar中test.properties Class.getResource()有2种方式，绝对路径和相对路径。绝对路径以/开头，从classpath或jar包根目录下开始搜索；相对路径是相对当前class所在的目录，允许使用..或.来定位文件。 ClassLoader.getResource()只能使用绝对路径，而且不用以/开头。 这两种方式读取资源文件，不会依赖于user.dir，也不会依赖于具体部署的环境，是推荐的做法。 我现在要读取其他jar中的文件，怎么办呢？？？实际上上述两种方式使用相对路径或绝对路径都能读取本jar或其他jar中的资源文件。但区别是，读取本jar包中的文件支持..这种写法，但是不能通过..读取其他jar下的文件。假设Xxxx.class的包路径为：com.beta.study，那么： Xxxx.class.getResource(“test.properties”);读取com/beta/study/test.properties 的文件，无论是本jar，还是其他jar中的文件；只要保证相对路径一致；也可以采用如下方式读取：Xxxx.class.getResource(“/com/beta/study/test.properties”);Xxxx.class.getClassLoader().getResource(“com/beta/study/test.properties”); 代码实战读取文件采用java的io流。根据上述背景知识，获取java stream的方式主要有：12345678//方式1：//Xxxx.class.getClassLoader().getResource(\"test.properties\"); 返回值也是java.net.URL，两种都行java.net.URL url = Xxxx.class.getResource(\"test.properties\");InputStream in = url.openStream() ;//方式2：其实getResourceAsStream底层实现和上述基本一致//Xxxx.class.getClassLoader().getResourceAsStream(\"test.properties\"); 返回值也是java.net.URL，两种都行InputStream in = Xxxx.class.getResourceAsStream(\"test.properties\"); 文件读取只要有如下方式： 按字符读取 按字节读取 按行读取 如下文件读取未对null判断，未对异常进行处理，实际实战需要进行处理。 1.按字符读取1234567891011121314InputStream inputStream = Xxxx.class.getResourceAsStream(\"test.properties\");try &#123; int tempbyte; StringBuilder stringBuilder = new StringBuilder(); while ( ( tempbyte = inputStream.read() ) != -1 ) &#123; char[] ch = Character.toChars(tempbyte); stringBuilder.append(ch); &#125; System.out.println(stringBuilder); inputStream.close();&#125;catch (Exception e) &#123;&#125; 2.按字节读取123456789101112131415InputStream inputStream = Xxxx.class.getResourceAsStream(\"test.properties\");try &#123; int size = 1024; byte[] readbytes = new byte[size]; StringBuilder stringBuilder = new StringBuilder(); int readSize = 0; while ( (readSize = inputStream.read(readbytes,0,size) ) != -1 ) &#123; stringBuilder.append(new String(readbytes,0,readSize)); &#125; System.out.println(stringBuilder); inputStream.close();&#125;catch (Exception e) &#123;&#125; 3.按行读取1234567891011121314InputStream inputStream = Xxxx.class.getResourceAsStream(\"test.properties\");try &#123; BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, \"utf-8\")); StringBuilder stringBuilder = new StringBuilder(); String line; while ( (line = br.readLine()) != null ) &#123; stringBuilder.append(line); &#125; System.out.println(stringBuilder); inputStream.close(); &#125;catch (Exception e) &#123;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://shiqiupp.github.io/tags/Java/"}]},{"title":"SpringBoot 多数据源实例","date":"2017-04-01T01:12:01.870Z","path":"2017/04/01/springboot-multi-datasources/","text":"需求背景大多数时候，一个项目不仅依赖一个数据源，往往需要多个数据源。如果项目使用SpringBoot+Mybatis结合进行数据持久层，在不采用传统的配置文件情况下，怎么通过注解的方式配置多个数据源呢？下面一一道来。如果读者还没有springboot的项目，推荐官方demo搭建平台：https://start.spring.io/完整代码详见：Github 环境说明 jdk1.7 , SpringBoot : 1.5.2.RELEASE , 数据源采用dbcp2 commons-dbcp2 : 2.1.1 maven依赖如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- log , 按需配置 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt;&lt;/dependency&gt; 代码实现配置文件首先新建数据源配置文件(recources/datasource.properties)，主要内容可参考如下：123456jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&amp;useSSL=truejdbc.username=rootjdbc.password=xxxxxxxxjdbc.maxActive=2335jdbc.maxIdel=120 代码实现tips: 所有的bean最好有名字，后续通过注解依赖注入式，可根据名字指定注入对应的bean; 新增一个默认数据源配置的类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import javax.sql.DataSource;import org.apache.commons.dbcp2.BasicDataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.context.annotation.PropertySource;import org.springframework.jdbc.datasource.DataSourceTransactionManager;@Configuration@PropertySource(\"classpath:datasource.properties\")//指定配置文件的路径和名字，按照实际配置@MapperScan(basePackages = DefaultDataSourceConfig.SCAN_PACKAGE , sqlSessionFactoryRef = \"defaultSqlSessionFactory\" /** 指定name=defaultSqlSessionFactory 的 sessionFactory **/)public class DefaultDataSourceConfig &#123; final static String SCAN_PACKAGE = \"com.beta.study.mapper.jdbc\"; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Value(\"$&#123;jdbc.maxActive&#125;\") private int maxActive; @Value(\"$&#123;jdbc.maxIdel&#125;\") private int maxIdel; @Bean(name=\"dataSource\") @Primary // 多个数据源，一定要有有一个关键的数据源 public DataSource getDataSource() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setMaxConnLifetimeMillis(maxActive); dataSource.setMaxIdle(maxIdel); dataSource.setValidationQuery(\"SELECT 1\"); dataSource.setTestOnBorrow(true); return dataSource; &#125; //这是配置数据源事务，不需要事务不需要配置 @Bean(name = \"defaultTransactionManager\") @Primary public DataSourceTransactionManager defaultDataSourceTransactionManager() &#123; return new DataSourceTransactionManager(getDataSource()); &#125; @Bean(name = \"defaultSqlSessionFactory\") @Primary public SqlSessionFactory defaultSqlSessionFactory(@Qualifier(\"dataSource\")DataSource dataSource /**@Qualifier指定注入name=dataSource 的数据源 **/) throws Exception &#123; final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); return sessionFactory.getObject(); &#125;&#125; 新增一个其他的数据源类（为了测试，两个数据源其实对应同一个数据库）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import javax.sql.DataSource;import org.apache.commons.dbcp2.BasicDataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.jdbc.datasource.DataSourceTransactionManager;@Configuration@PropertySource(\"classpath:datasource.properties\")@MapperScan(basePackages = SecondDataSourceConfig.SCAN_PACKAGE , sqlSessionFactoryRef = \"secondSqlSessionFactory\")public class SecondDataSourceConfig &#123; final static String SCAN_PACKAGE = \"com.beta.study.mapper.secondjdbc\"; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Value(\"$&#123;jdbc.maxActive&#125;\") private int maxActive; @Value(\"$&#123;jdbc.maxIdel&#125;\") private int maxIdel; @Bean(name=\"secondDataSource\") public DataSource getDataSource() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setMaxConnLifetimeMillis(maxActive); dataSource.setMaxIdle(maxIdel); dataSource.setValidationQuery(\"SELECT 1\"); dataSource.setTestOnBorrow(true); return dataSource; &#125; @Bean(name = \"secondTransactionManager\") public DataSourceTransactionManager defaultDataSourceTransactionManager() &#123; return new DataSourceTransactionManager(getDataSource()); &#125; @Bean(name = \"secondSqlSessionFactory\") public SqlSessionFactory defaultSqlSessionFactory(@Qualifier(\"secondDataSource\")DataSource dataSource) throws Exception &#123; final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); return sessionFactory.getObject(); &#125;&#125; 对应mapper的类，注意具体的package名123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.beta.study.mapper.jdbc;import java.util.List;import com.beta.study.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Result;import org.apache.ibatis.annotations.Results;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.type.JdbcType;@Mapperpublic interface UserMapper &#123; @Select(\"select * from user\") @Results(value = &#123; @Result(id = true,column = \"id\",property = \"id\",jdbcType = JdbcType.INTEGER,javaType = Integer.class), @Result(column = \"user_name\",property = \"userName\",jdbcType = JdbcType.VARCHAR,javaType = String.class), @Result(column = \"nick\",property = \"nick\",jdbcType = JdbcType.VARCHAR,javaType = String.class), @Result(column = \"text\",property = \"text\",jdbcType = JdbcType.VARCHAR,javaType = String.class) &#125;) List&lt;User&gt; getAllUsers();&#125;package com.beta.study.mapper.secondjdbc;import java.util.List;import com.beta.study.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Result;import org.apache.ibatis.annotations.Results;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.type.JdbcType;@Mapperpublic interface SecondUserMapper &#123; @Select(\"select * from user\") @Results(value = &#123; @Result(id = true,column = \"id\",property = \"id\",jdbcType = JdbcType.INTEGER,javaType = Integer.class), @Result(column = \"user_name\",property = \"userName\",jdbcType = JdbcType.VARCHAR,javaType = String.class), @Result(column = \"nick\",property = \"nick\",jdbcType = JdbcType.VARCHAR,javaType = String.class), @Result(column = \"text\",property = \"text\",jdbcType = JdbcType.VARCHAR,javaType = String.class) &#125;) List&lt;User&gt; getAllUsers();&#125; 编写启动类：12345678910111213package com.beta.study;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Main &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Main.class, args); &#125;&#125; OK , 运行Main，不出意外，整个项目就跑起来了~如果有疑问，欢迎咨询，邮箱：shiqiu-beta@qq.com","tags":[{"name":"Java","slug":"Java","permalink":"https://shiqiupp.github.io/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://shiqiupp.github.io/tags/SpringBoot/"},{"name":"多数据源","slug":"多数据源","permalink":"https://shiqiupp.github.io/tags/多数据源/"}]},{"title":"Hello World","date":"2017-03-31T03:06:19.723Z","path":"2017/03/31/hello-world/","text":"欢迎光临时秋的博客小站~博客更新中………….么么哒","tags":[]}]